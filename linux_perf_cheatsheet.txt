
========================================================
* top
------

Ref: man top
                         system load avg over the last 1, 5 and 15 minutes
      current time       load average = running + waiting threads
        |    time since last boot                    |
        |         |                                  |
        v         v                                  v
top - 08:54:25 up 37 days,  8:58, 11 users,  load average: 1.77, 0.57, 0.19 
Tasks: 321 total,   1 running, 204 sleeping,   0 stopped,   0 zombie
        ^ 
       total tasks or threads         time waiting for I/O completion (disk)
                                 time in kernel| idle handler
                                     |         |       time spent servicing hardware interrupts
                                     |         |        |
                                     v         v        v
%Cpu(s):  4.9 us,  1.5 sy,  0.0 ni, 93.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st <-+
          ^           ^       ^niced user processes              ^        time stolen from this vm by the hypervisor
          |           |                                          |
          |       time kernel processes                   time spent servicing software interrupts
         time running un-niced user processes                         cache: read from the disk
                                                                       v 
KiB Mem : 24210912 total,  7884172 free,  2635336 used, 13691404 buff/cache
^          ^                                                      ^ 
|         total = free + used +  buff/cache                 buffers:yet to be written to disk
Physical memory in KiB(kibibyte) = 1024 bytes
KiB Swap:        0 total,        0 free,        0 used. 21357152 avail Mem 

task's priority. From -20 to 19, with -20 being most important
                |  Niceness: -20 (most favorable) to 19 (least favorable ).
                v   v
  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                
31194 narwhal   20   0  357412  45168  12188 S 104.3  0.2   2:57.76 handler_perf_te                                        
31192 narwhal   20   0   42924   4180   3396 R   0.7  0.0   0:00.76 top                                                    
31130 narwhal   20   0  330372  38348  19236 S   0.3  0.2   0:01.67 emacs                                                  
    1 root      20   0   78156   6544   3916 S   0.0  0.0   0:59.73 systemd                                                
    2 root      20   0       0      0      0 S   0.0  0.0   0:00.55 kthreadd                                               
    4 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 kworker/0:0H                                           
    5 root      20   0       0      0      0 I   0.0  0.0   0:01.63 kworker/u128:0                                         
    7 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 mm_percpu_wq                                           
    8 root      20   0       0      0      0 S   0.0  0.0   1:04.08 ksoftirqd/0                                            
    9 root      20   0       0      0      0 I   0.0  0.0  15:59.09 rcu_sched                                              
   10 root      20   0       0      0      0 I   0.0  0.0   0:00.00 rcu_bh                                                 
   11 root      rt   0       0      0      0 S   0.0  0.0   0:01.01 migration/0                                            
   12 root      rt   0       0      0      0 S   0.0  0.0   0:09.33 watchdog/0                                             
   13 root      20   0       0      0      0 S   0.0  0.0   0:00.00 cpuhp/0                                                
   14 root      20   0       0      0      0 S   0.0  0.0   0:00.00 cpuhp/1                                                
   15 root      rt   0       0      0      0 S   0.0  0.0   0:08.38 watchdog/1                                             
   16 root      rt   0       0      0      0 S   0.0  0.0   0:00.80 migration/1                                            
   17 root      20   0       0      0      0 S   0.0  0.0   0:30.31 ksoftirqd/1                                            
   19 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 kworker/1:0H                                           
   20 root      20   0       0      0      0 S   0.0  0.0   0:00.00 cpuhp/2                                                
   21 root      rt   0       0      0      0 S   0.0  0.0   0:09.78 watchdog/2                                             
   22 root      rt   0       0      0      0 S   0.0  0.0   0:00.83 migration/2                                            

==================================================================
* /proc/meminfo

Ref: https://www.kernel.org/doc/Documentation/filesystems/proc.txt

$ cat /proc/meminfo
MemTotal:       24210912 kB <-- physical ram size
MemFree:         7465412 kB 
MemAvailable:   20939500 kB <-- memory is available for starting new applications
Buffers:          560476 kB <-- temporary storage for raw disk blocks
Cached:         12487660 kB <-- in-memory cache for files read from the disk (the page cache)
SwapCached:            0 kB
Active:          6260388 kB <-- Kernel memory that has been used more recently
Inactive:        9389976 kB <-- Kernel memory which has been less recently used (It is more eligible to be reclaimed for other purposes)
Active(anon):    1369780 kB <-- user space processes recently used memory
Inactive(anon):  1233564 kB <-- user space processes less recently used memory
Active(file):    4890608 kB <-- Kernel cache for files that was read from disk (recently used)
Inactive(file):  8156412 kB <-- Kernel cache for files that was read from disk (less recently used)
                               Note: Cached = Active(file) + Inactive(file)
Unevictable:           0 kB
Mlocked:               0 kB
SwapTotal:             0 kB
SwapFree:              0 kB
Dirty:                36 kB
Writeback:             0 kB
AnonPages:       2600360 kB
Mapped:            78340 kB
Shmem:              1056 kB
Slab:             819012 kB
SReclaimable:     644364 kB
SUnreclaim:       174648 kB
KernelStack:        7248 kB
PageTables:        16568 kB
NFS_Unstable:          0 kB
Bounce:                0 kB
WritebackTmp:          0 kB
CommitLimit:    12105456 kB
Committed_AS:    3328516 kB
VmallocTotal:   34359738367 kB
VmallocUsed:           0 kB
VmallocChunk:          0 kB
HardwareCorrupted:     0 kB
AnonHugePages:         0 kB
ShmemHugePages:        0 kB
ShmemPmdMapped:        0 kB
CmaTotal:              0 kB
CmaFree:               0 kB
HugePages_Total:       0
HugePages_Free:        0
HugePages_Rsvd:        0
HugePages_Surp:        0
Hugepagesize:       2048 kB
DirectMap4k:     1134528 kB
DirectMap2M:    23506944 kB
DirectMap1G:     1048576 kB

===================================
* vmstat


narwhal@narwhal:~$ vmstat 2 10 
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache    si   so    bi    bo   in   cs us sy id wa st
 1  0      0 7454868 562308 13136452  0    1    12    23    0    1  0  0 98  1  0
 0  0      0 7454744 562308 13136452  0    0     0     0   12  100  0  0 100  0  0
 0  0      0 7454868 562316 13136444  0    0     0     6    8   90  0  0 100  0  0
 0  0      0 7454868 562316 13136444  0    0     0     0    6   74  0  0 100  0  0
 0  0      0 7454996 562316 13136452  0    0     0     0   16  110  0  0 100  0  0
 0  0      0 7455120 562316 13136452  0    0     0     0    6   63  0  0 100  0  0
 0  0      0 7455120 562316 13136452  0    0     0     0    6   84  0  0 100  0  0
 0  0      0 7455244 562316 13136452  0    0     0     0   11   83  0  0 100  0  0
 0  0      0 7455368 562316 13136452  0    0     0     0   33  189  0  0 100  0  0
 0  0      0 7455368 562316 13136452  0    0     0     0   14   80  0  0 100  0  0
 ^
 r: The number of runnable processes (running or waiting for run time).
 b: The number of processes in uninterruptible sleep.

narwhal@narwhal:~$ 
=======================================
* iotop

gives info by process

$sudo iotop

Total DISK READ :       0.00 B/s | Total DISK WRITE :       2.49 M/s
Actual DISK READ:       0.00 B/s | Actual DISK WRITE:      49.77 K/s
  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO>    COMMAND
  496 be/3 root        0.00 B/s   26.80 K/s  0.00 %  5.79 % [jbd2/dm-0-8]
32086 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.34 % [kworker/u130:3]
38666 be/4 narwhal     0.00 B/s    2.46 M/s  0.00 %  0.06 % cc1plus -quiet -I /home/narwhal/~orcasql-mysql/source_downloads/g
    1 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % init maybe-ubiquity
    2 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kthreadd]
    4 be/0 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kworker/0:0H]
    5 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kworker/u128:0]
    7 be/0 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [mm_percpu_wq]
    8 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [ksoftirqd/0]
    9 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [rcu_sched]
   10 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [rcu_bh]
   11 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [migration/0]
   12 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [watchdog/0]
   13 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [cpuhp/0]
   14 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [cpuhp/1]
   15 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [watchdog/1]
   16 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [migration/1]
   17 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [ksoftirqd/1]
   19 be/0 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kworker/1:0H]
   20 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [cpuhp/2]
   21 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [watchdog/2]
   22 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [migration/2]
   23 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [ksoftirqd/2]
   25 be/0 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kworker/2:0H]
   26 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [cpuhp/3]
   27 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [watchdog/3]
   28 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [migration/3]
   29 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [ksoftirqd/3]
   31 be/0 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kworker/3:0H]

=================================
* iostat

gives info by devices
==========================
* cachegrind * callgrind
Callgrind is a profiling tool that records the call history among functions in a program's run as a call-graph.
Shows the following:-
  - number of instructions executed, their relationship to source lines, the caller/callee relationship between functions, and the numbers of such calls
  - cache simulation and/or branch prediction (similar to Cachegrind) can produce further information about the runtime behavior of an application

Ref: https://valgrind.org/docs/manual/cl-manual.html
     https://accu.org/journals/overload/20/111/floyd_1886/ good

Installation:-
sudo apt-get install  valgrind
sudo apt-get install  kcachegrind

valgrind --tool=cachegrind --log-file=cg.out --branch-sim=yes ./badprime

# run cache and branch-predictor profiler
# 
$ valgrind --tool=cachegrind --branch-sim=yes --cache-sim=yes --cachegrind-out-file=chg.out /tmp/simple


# run call graph simulator and branch-predictor emulator
# 
$ valgrind --tool=callgrind --branch-sim=yes --cacheuse=yes --callgrind-out-file=clg.out /tmp/simple


kcachegrind chg.out 

============================
https://github.com/iovisor/bcc/blob/master/tools/trace_example.txt userspace
https://github.com/iovisor/bcc
https://github.com/iovisor/bcc/blob/master/tools/wakeuptime_example.txt
./wakeuptime -u          # don't include kernel threads (user only)
==========================================================================
* mutrace Measuring mutex lock contention

Ref: http://0pointer.de/blog/projects/mutrace.html

sudo apt-get install mutrace

Note:
 - This tool report lock contention (valgrind drd does not report contention)
 - link with -rdynamic for better traces
   gcc -O -g3  simple.cc -o /tmp/simple -lpthread -rdynamic;
 - program has to exit to capture traces

~/linux_perf_cheatsheet$ mutrace /tmp/simple
mutrace: 0.2 sucessfully initialized for process simple (pid 53366).
io_threads are running ...
cpu_threads are running ...

  C-c C-cTerminating due to signal:2

mutrace: Showing statistics for process simple (pid 53366).
mutrace: 3 mutexes used.

Mutex #1 (0x0x560d19982080) first referenced by:
	/usr/lib/mutrace/libmutrace.so(pthread_mutex_lock+0x47) [0x7f5601935827]
	/tmp/simple(_Z19cpu_thread_functionPv+0x46) [0x560d19780ed6]

Mutex #0 (0x0x560d19982040) first referenced by:
	/usr/lib/mutrace/libmutrace.so(pthread_mutex_lock+0x47) [0x7f5601935827]
	/tmp/simple(_Z19cpu_thread_functionPv+0x60) [0x560d19780ef0]

Mutex #2 (0x0x560d199820c0) first referenced by:
	/usr/lib/mutrace/libmutrace.so(pthread_mutex_lock+0x47) [0x7f5601935827]
	/tmp/simple(_Z19cpu_thread_functionPv+0x2c) [0x560d19780ebc]

mutrace: Showing 3 most contended mutexes:
                           Contention: Times lock was already taken when we tried to take it and we had to wait.    
 Times the mutex was locked     | 
            |   Times the owning| thread of the mutex changed
            |       |           |   Total time of the lock    Longest time lock was held
            |       |           |     |                         |
            v       v           v     v                         v
 Mutex #   Locked  Changed    Cont. tot.Time[ms] avg.Time[ms] max.Time[ms]  Flags
       1        6        5        3    10000.704     1666.784     2000.162 M-.--.  <-- Mutex
       0        4        3        3     9000.447     2250.112     3000.168 M-.--.
       2        6        5        2     6000.983     1000.164     1000.184 M-.--.
                                                                           ||||||
                                                                           /|||||
          Object:                                     M = Mutex, W = RWLock /||||
           State:                                 x = dead, ! = inconsistent /|||
             Use:                                 R = used in realtime thread /||
      Mutex Type:                 r = RECURSIVE, e = ERRRORCHECK, a = ADAPTIVE /|
  Mutex Protocol:                                      i = INHERIT, p = PROTECT /
     RWLock Kind: r = PREFER_READER, w = PREFER_WRITER, W = PREFER_WRITER_NONREC 

mutrace: Note that the flags column R is only valid in --track-rt mode!

mutrace: Total runtime is 13614.505 ms.

mutrace: Results for SMP with 16 processors.


* drd valgrind 

Linux valgrind's drd can be used to track down long held mutexes.
Note: This does not find mutex contention.
Ref: https://www.valgrind.org/docs/manual/drd-manual.html

Reports all locks that are held for more than 10ms (--exclusive-threshold=10)
narwhal@narwhal:~/linux_perf_cheatsheet$ valgrind --tool=drd  --exclusive-threshold=10 /tmp/simple
==53405== drd, a thread error detector
==53405== Copyright (C) 2006-2017, and GNU GPL'd, by Bart Van Assche.
==53405== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==53405== Command: /tmp/simple
==53405== 
io_threads are running ...
cpu_threads are running ...
==53405== Thread 3: <-- Thread 3 acquired mutex at line simple.cc:51 an held it for 1001 ms
==53405== Acquired at:
==53405==    at 0x4C39193: pthread_mutex_lock (in /usr/lib/valgrind/vgpreload_drd-amd64-linux.so)
==53405==    by 0x108EBB: cpu_thread_function(void*) (simple.cc:49)
==53405==    by 0x4C36413: ??? (in /usr/lib/valgrind/vgpreload_drd-amd64-linux.so)
==53405==    by 0x4E556DA: start_thread (pthread_create.c:463)
==53405==    by 0x518EA3E: clone (clone.S:95)
==53405== Lock on mutex 0x30a0c0 was held during 1001 ms (threshold: 10 ms).
==53405==    at 0x4C3A123: pthread_mutex_unlock (in /usr/lib/valgrind/vgpreload_drd-amd64-linux.so)
==53405==    by 0x108ECD: cpu_thread_function(void*) (simple.cc:51)
==53405==    by 0x4C36413: ??? (in /usr/lib/valgrind/vgpreload_drd-amd64-linux.so)
==53405==    by 0x4E556DA: start_thread (pthread_create.c:463)
==53405==    by 0x518EA3E: clone (clone.S:95)
==53405== mutex 0x30a0c0 was first observed at:
==53405==    at 0x4C390D3: pthread_mutex_lock (in /usr/lib/valgrind/vgpreload_drd-amd64-linux.so)
==53405==    by 0x108EBB: cpu_thread_function(void*) (simple.cc:49)
==53405==    by 0x4C36413: ??? (in /usr/lib/valgrind/vgpreload_drd-amd64-linux.so)
==53405==    by 0x4E556DA: start_thread (pthread_create.c:463)
==53405==    by 0x518EA3E: clone (clone.S:95)
==53405== 
==53405== Acquired at:
==53405==    at 0x4C39193: pthread_mutex_lock (in /usr/lib/valgrind/vgpreload_drd-amd64-linux.so)
==53405==    by 0x108ED5: cpu_thread_function(void*) (simple.cc:53)
==53405==    by 0x4C36413: ??? (in /usr/lib/valgrind/vgpreload_drd-amd64-linux.so)
==53405==    by 0x4E556DA: start_thread (pthread_create.c:463)
==53405==    by 0x518EA3E: clone (clone.S:95)
==53405== Lock on mutex 0x30a080 was held during 2001 ms (threshold: 10 ms).
==53405==    at 0x4C3A123: pthread_mutex_unlock (in /usr/lib/valgrind/vgpreload_drd-amd64-linux.so)
==53405==    by 0x108EE7: cpu_thread_function(void*) (simple.cc:55)
==53405==    by 0x4C36413: ??? (in /usr/lib/valgrind/vgpreload_drd-amd64-linux.so)
==53405==    by 0x4E556DA: start_thread (pthread_create.c:463)
==53405==    by 0x518EA3E: clone (clone.S:95)
==53405== mutex 0x30a080 was first observed at:
==53405==    at 0x4C390D3: pthread_mutex_lock (in /usr/lib/valgrind/vgpreload_drd-amd64-linux.so)
==53405==    by 0x108ED5: cpu_thread_function(void*) (simple.cc:53)
==53405==    by 0x4C36413: ??? (in /usr/lib/valgrind/vgpreload_drd-amd64-linux.so)
==53405==    by 0x4E556DA: start_thread (pthread_create.c:463)
==53405==    by 0x518EA3E: clone (clone.S:95)
==53405== 
==53405== Acquired at:
==53405==    at 0x4C39193: pthread_mutex_lock (in /usr/lib/valgrind/vgpreload_drd-amd64-linux.so)
==53405==    by 0x108EEF: cpu_thread_function(void*) (simple.cc:57)
==53405==    by 0x4C36413: ??? (in /usr/lib/valgrind/vgpreload_drd-amd64-linux.so)
==53405==    by 0x4E556DA: start_thread (pthread_create.c:463)
==53405==    by 0x518EA3E: clone (clone.S:95)
==53405== Lock on mutex 0x30a040 was held during 3001 ms (threshold: 10 ms).
==53405==    at 0x4C3A123: pthread_mutex_unlock (in /usr/lib/valgrind/vgpreload_drd-amd64-linux.so)
==53405==    by 0x108F01: cpu_thread_function(void*) (simple.cc:59)
==53405==    by 0x4C36413: ??? (in /usr/lib/valgrind/vgpreload_drd-amd64-linux.so)
==53405==    by 0x4E556DA: start_thread (pthread_create.c:463)
==53405==    by 0x518EA3E: clone (clone.S:95)
==53405== mutex 0x30a040 was first observed at:
==53405==    at 0x4C390D3: pthread_mutex_lock (in /usr/lib/valgrind/vgpreload_drd-amd64-linux.so)
==53405==    by 0x108EEF: cpu_thread_function(void*) (simple.cc:57)
==53405==    by 0x4C36413: ??? (in /usr/lib/valgrind/vgpreload_drd-amd64-linux.so)
==53405==    by 0x4E556DA: start_thread (pthread_create.c:463)
==53405==    by 0x518EA3E: clone (clone.S:95)
==53405== 
=========================================================================================
* perf



man perf-probe

       Add probes at zfree() function on /bin/zsh

           ./perf probe -x /bin/zsh zfree or ./perf probe /bin/zsh zfree

       Add probes at malloc() function on libc

           ./perf probe -x /lib/libc.so.6 malloc or ./perf probe /lib/libc.so.6 malloc



https://www.percona.com/sites/default/files/ple19-slides/day1-pm/tracing-and-profiling-mysql.pdf

Adding uprobes to MySQL dynamically with perf
● The idea was to add dynamic probe to capture SQL queries
● This was done on Ubuntu 16.04 with recent Percona Server 5.7
● First I had to find out with gdb where is the query (hint: dispatch_command
has com_data parameter):
(gdb) p com_data->com_query.query
$4 = 0x7fb0dba8d021 "select 2"
● Then it’s just as easy as follows:
openxs@ao756:~$ sudo perf probe -x /usr/sbin/mysqld 'dispatch_command
com_data->com_query.query:string'
openxs@ao756:~$ sudo perf record -e 'probe_mysqld:dispatch_command*' -aR
^C[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.676 MB perf.data (3 samples) ]
openxs@ao756:~$ sudo perf script >/tmp/queries.txt
openxs@ao756:~$ sudo perf probe --del dispatch_command



=========================================================================================

* bpftrace

Installation
-------------
Ref: https://snapcraft.io/install/bpftrace/ubuntu
$ sudo snap install bpftrace
$ sudo snap connect bpftrace:system-trace

(not needed
https://www.flagword.net/2020/03/my-experience-with-kernel-lockdown-and-ebfp/
As a dirty hack I’ve used Alt+SysRq option so far. Btw, to initiate Alt+SysRq on Dell 7390 I had to:
1. Press Fn+Esc to enable function keys
2. Press Alt+PrtScr+x to disable lockdown


bpftrace -e 'u:/lib/x86_64-linux-gnu/libc-2.27.so:malloc { @[ustack(5)] = sum(arg0); }'

Code needs to be instrumented
Ref:
https://github.com/iovisor/bpftrace
https://github.com/iovisor/bpftrace/blob/master/docs/tutorial_one_liners.md
https://www.percona.com/sites/default/files/presentations/Scale18x-2020-bpfTrace-finally-dTrace-replacement.pdf
https://www.joyfulbikeshedding.com/blog/2019-01-31-full-system-dynamic-tracing-on-linux-using-ebpf-and-bpftrace.html#usdt-probe-example

bpftrace -e 'uprobe:/tmp/simple:_Z19cpu_thread_functionPv { printf("%d\n", str(arg1)); }'

bpftrace -e 'uprobe:/tmp/simple:_Z19cpu_thread_functionPv { printf("FOO\n"); }'

===========================
* stap *systemtap

SystemTap is a tracing and probing tool that allows users to study and monitor the activities of the computer system (particularly, the kernel) in fine detail. It provides information similar to the output of tools like netstat, ps, top, and iostat, but is designed to provide more filtering and analysis options for collected information.

In Ubuntu distro works only for user process, not for kernel. "However, SystemTap never fully merged into the Linux kernel (parts did, like uprobes), so as an out-of-tree project it required maintenance to work at all, and Red Hat only did this for RHEL." Ref: http://www.brendangregg.com/blog/2018-10-08/dtrace-for-linux-2018.html

Ref: https://sourceware.org/systemtap/langref/ GOOD one
     https://sourceware.org/systemtap/SystemTap_Beginners_Guide/
     all functions https://manpages.debian.org/testing/systemtap-doc/index.html

Example: Print call trace
-------------------------------
wget https://sourceware.org/systemtap/examples/general/para-callgraph.stp
-v verbose
-c CMD Start  the  probes, run CMD, and exit when CMD finishes.
-x PID Sets  target()  to PID.
linux_perf_cheatsheet/scripts$ sudo stap para-callgraph.stp  'process("/tmp/simple").function("*")'  -v -c "/tmp/simple > /dev/null"

    microsecond           Function with args
    |         Thread id    |    
    |          |           v
   545 simple(8163):   ->f1 c=0x16
     0 simple(8166):->io_thread_function vargp=0x7ffd18fe773c
     0 simple(8167):->cpu_thread_function vargp=0x7ffd18fe773c
    25 simple(8167): ->f3 a=0x14
    39 simple(8167):  ->f2 b=0x15
    52 simple(8167):   ->f1 c=0x16
    65 simple(8167):   <-f1 
    70 simple(8167):  <-f2 
    75 simple(8167): <-f3 
  1127 simple(8165):   <-f1 
  1137 simple(8165):  <-f2 
  1142 simple(8165): <-f3 
  1455 simple(8163):   <-f1 
  1464 simple(8163):  <-f2 
  1469 simple(8163): <-f3 
6000710 simple(8167): ->f3 a=0x14
6000741 simple(8167):  ->f2 b=0x15
6000756 simple(8167):   ->f1 c=0x16
6000772 simple(8167):   <-f1 
6000777 simple(8167):  <-f2 
6000781 simple(8167): <-f3 


List matching probes and local variables of function f1:-
------------------------------------------------------------
$sudo stap  -L 'process("/tmp/simple").function("f1")'
narwhal@narwhal:~/linux_perf_cheatsheet/scripts$ process("/tmp/simple").function("f1@/home/narwhal/linux_perf_cheatsheet/simple.cc:50") $c:int $c1:class C1 <-- shows variables that can be accessed 
void f1(int c) {
  C1 c1;
  c1.m1 = 1;
  c1.m2 = 2;
  c1.m3 = 3;
  for (int i = 0; i > 0; i++) {
    i = i + 1;
  }
  printf(".");
}


List matching probes in a file or library
------------------------------------------------------------
$ sudo stap -l 'process("/tmp/simple").function("*")'
[sudo] password for narwhal: 
process("/tmp/simple").function("__do_global_dtors_aux")
process("/tmp/simple").function("__libc_csu_fini")
process("/tmp/simple").function("__libc_csu_init")
process("/tmp/simple").function("_fini")
process("/tmp/simple").function("_init")
process("/tmp/simple").function("_start")
process("/tmp/simple").function("cpu_thread_function@/home/narwhal/linux_perf_cheatsheet/simple.cc:63")
process("/tmp/simple").function("deregister_tm_clones")
process("/tmp/simple").function("f1@/home/narwhal/linux_perf_cheatsheet/simple.cc:50")
process("/tmp/simple").function("f2@/home/narwhal/linux_perf_cheatsheet/simple.cc:61")
process("/tmp/simple").function("f3@/home/narwhal/linux_perf_cheatsheet/simple.cc:62")
process("/tmp/simple").function("frame_dummy")
process("/tmp/simple").function("io_thread_function@/home/narwhal/linux_perf_cheatsheet/simple.cc:82")
process("/tmp/simple").function("main@/home/narwhal/linux_perf_cheatsheet/simple.cc:127")
process("/tmp/simple").function("open@/usr/include/x86_64-linux-gnu/bits/fcntl2.h:41")
process("/tmp/simple").function("printf@/usr/include/x86_64-linux-gnu/bits/stdio2.h:102")
process("/tmp/simple").function("register_tm_clones")
process("/tmp/simple").function("sigint_handler@/home/narwhal/linux_perf_cheatsheet/simple.cc:45")
process("/tmp/simple").function("sprintf@/usr/include/x86_64-linux-gnu/bits/stdio2.h:31")

narwhal@narwhal:~/linux_perf_cheatsheet/scripts$ sudo stap -l 'process("/home/narwhal/orcasql-mysql/out/storage/vml/libvml.so").function("*")'
process("/home/narwhal/orcasql-mysql/out/storage/vml/libvml.so").function("AbortTx@/home/narwhal/orcasql-mysql/storage/vml/metadata/UndurableStorage.cc:340")
process("/home/narwhal/orcasql-mysql/out/storage/vml/libvml.so").function("Acquire@/home/narwhal/orcasql-mysql/storage/vml/io_fence/FileLockBasedIoFence.cc:28")
process("/home/narwhal/orcasql-mysql/out/storage/vml/libvml.so").function("Acquire@/home/narwhal/orcasql-mysql/storage/vml/io_fence/IoFenceManager.cc:25")
process("/home/narwhal/orcasql-mysql/out/storage/vml/libvml.so").function("Acquire@/home/narwhal/orcasql-mysql/storage/vml/io_fence/ScsiBasedIoFence.cc:492")
process("/home/narwhal/orcasql-mysql/out/storage/vml/libvml.so").function("AcquireWriteExclusiveAccess@/home/narwhal/orcasql-mysql/storage/vml/io_fence/Scsi


Example: more comprehensive user process tracing
-------------------------------------------------
in another window start: /tmp/simple


sudo stap -v -e '
probe process("/tmp/simple").function("f1")
   {
     printf(" Program name:%s", execname());
     printf(" cpu:%d",  cpu());
     printf(" pid:%d", pid());
     printf(" tid:%d", tid());
     printf(" function:%s", ppfunc() );
     printf(" Local variables:%s",$$vars);
     // refer program variables using $ such as $c1
     printf(" Variable c1.m3:%d",$c1->m3);     
     
     printf("\n");
     print_ubacktrace();
   }

probe process("/tmp/simple").statement("*@simple.cc:58").nearest
   {
     // $$..$$ prints nested classes structures
     printf(" In function function:%s", ppfunc() );     
     printf(" Locals: %s", $$locals$$);
     printf("Params: %s", $$parms);
     // prints variables in scope: class members also     
     printf(" Variables in scope: %s", $$vars$$);
     printf("\n");
   }

probe process("/tmp/simple").thread.begin
   {
        printf(" tid:%d started", tid());
   }

probe process("/tmp/simple").thread.end
   {
        printf(" tid:%d ended", tid());
   }

probe process("/tmp/simple").syscall
   {
        printf("%s called %s\n", syscall_name($syscall),  $$parms);
   }

probe process("/tmp/simple").syscall.return
   {
        // does not work: time =  gettimeofday_ns() - @entry(gettimeofday_ns());
        printf("%s ret:%d\n", syscall_name($syscall), $return);
   }

global f3_time;
probe process("/tmp/simple").function("f3").return
   {
      // operator <<< stores the value in the aaray "f3_time"
      f3_time <<< gettimeofday_ns() - @entry(gettimeofday_ns());
   }

probe end
   {
     printf(" function f3 time stats in nano seconds\n");
     print(" count:", @count(f3_time));
     print(" min:", @min(f3_time));
     print(" max:", @max(f3_time));
     print(" avg:", @avg(f3_time));     

     print(" Histogram:\n");
     print(@hist_log(f3_time));
   }

'



Example: mega code tracing and function latency measurement
---------------------------------------------------------------
GOOD
To call trace or measure a large/medium project use these steps

1. update variables in stap_process_find_function_probes.py and generate the list of functions and corresponding probes.
python3 stap_process_find_function_probes.py  > /tmp/function_probes.txt

2.
  - based on /tmp/function_probes.txt update the .call call and .return probes in mega-callgraph.stp
  - update verbose variable in mega-callgraph.stp
  - this requires about 8G memory during compilation!!
  - Adjust MAXMAPENTRIES to the number of function probes.
  - Run as follows
sudo stap -g --suppress-time-limits -v -DMAXMAPENTRIES=10000 -DMAXSKIPPED=100000  mega-callgraph.stp
Pass 1: parsed user script and 465 library scripts using 116376virt/51084res/6836shr/44696data kb, in 330usr/60sys/832real ms.
Pass 2: analyzed script: 3400 probes, 7556 functions, 4 embeds, 2268 globals using 286136virt/222432res/8232shr/214456data kb, in 377010usr/2650sys/400102real ms.
Pass 3: translated to C into "/tmp/stapQHy5dG/stap_d5aeeab3409fe551afedf1287cdf04a9_15083112_src.c" using 286136virt/222640res/8428shr/214456data kb, in 79320usr/490sys/79807real ms.
/tmp/stapQHy5dG/stap_d5aeeab3409fe551afedf1287cdf04a9_15083112_src.c: In function ‘probe_8294’:
/tmp/stapQHy5dG/stap_d5aeeab3409fe551afedf1287cdf04a9_15083112_src.c:794692:0: note: -Wmisleading-indentation is disabled from this point onwards, since column-tracking was disabled due to the size of the code/headers
             c->actionremaining -= 2;
 
Pass 4: compiled C into "stap_d5aeeab3409fe551afedf1287cdf04a9_15083112.ko" in 1010300usr/16230sys/1017915real ms.
Pass 5: starting run.


Sample output:- with verbose=1 and with call and return probes: process("/home/narwhal/orcasql-mysql/out/storage/vml/libvml.so").function("PerformWriteInternal").return
->PerformWriteInternal this={.m_aioContext=0x5622867d2f00, .m_filePath={._M_dataplus={._M_p="/tmp/chunk9.raw"}, ._M_string_length=15, <union>={._M_local_buf="/tmp/chunk9.raw", ._M_allocated_capacity=8460120955416310831}}, .m_fdBuffered=9, .m_fdUnbuffered=10, .m_isBlockDevice=0} ioRequest={.ioRequestType=1, .buf="8<l\277", .numBytes=16384, .offset=184614912, .cancelled=0, .chunkHandler=0x56228679b950, .cb=0x7f6837a60ffe, .cbParam=0x7f6624000e90, .ioAttrsAndStat=0x7f6624000f60} iocb={.data=0x0, .key=0, .__pad2=0, .aio_lio_opcode=0

<-PerformWriteInternal return=0x1 latency:2628 micro sec tid:5909 cpu:14


Sample output: without verbose=0 
Pass 1: parsed user script and 465 library scripts using 114388virt/49356res/6956shr/42708data kb, in 260usr/20sys/279real ms.
Pass 2: analyzed script: 27 probes, 29 functions, 4 embeds, 26 globals using 116376virt/52752res/8144shr/44696data kb, in 80usr/220sys/307real ms.
Pass 3: translated to C into "/tmp/stapIAZSXk/stap_093f662386cfef37de7929734d9fa9c1_38571_src.c" using 116524virt/53048res/8336shr/44844data kb, in 40usr/200sys/236real ms.
Pass 4: compiled C into "stap_093f662386cfef37de7929734d9fa9c1_38571.ko" in 6080usr/1530sys/7204real ms.
Pass 5: starting run.
function:isPrime, latency microsec mean:17, variance:160 std-dev:sqrt(160) count:11943112 total:203032904 
function:f1, latency microsec mean:22081709, variance:2597419322830 std-dev:sqrt(2597419322830) count:11 total:242898799  WATCH THIS
function:f2, latency microsec mean:22081831, variance:2597862025340 std-dev:sqrt(2597862025340) count:11 total:242900141  WATCH THIS
function:f3, latency microsec mean:22081936, variance:2598299091940 std-dev:sqrt(2598299091940) count:11 total:242901296  WATCH THIS
function:io_thread_function, latency microsec mean:110972865, variance:392206268808 std-dev:sqrt(392206268808) count:3 total:332918595  WATCH THIS


What probes are available:
-----------------------------
Ref: https://sourceware.org/systemtap/man/stapprobes.3stap.html (see sections USER-SPACE, Java)
process("PATH").function("NAME")
  - Places a probe near the beginning of the named function, so that parameters are available as context variables.
process("PATH").statement("*@FILE.c:123")
  -  Places a probe at the exact spot, exposing those local variables that are visible there.
process("PATH").library("PATH").function("NAME")
process("PATH").library("PATH").statement("*@FILE.c:123")
  -  Places a probe at the exact spot, exposing those local variables that are visible there.
process("PATH").library("PATH").statement("*@FILE.c:123").nearest
process("PATH").function("*").return
  - Places a probe at the moment after the return from the named function, so the return value is available as the "$return" context variable.
process("PATH").function("myfun").label("foo")
process("PATH").function("foo").callee("bar")
  - Places a probe on the callee function given in the .callee modifier, where the callee must be a function called by the target function given in .function. calls through function pointers are not available.
process("PATH").function("foo").callee("bar").return
process("PATH").function("foo").callee("bar").call
process("PATH").function("foo").callees(DEPTH)
  - Recursively places probes on callees. 
process(PID).function("NAME")
process(PID).function("myfun").label("foo")
process(PID).plt("NAME")
 - ?? A .plt probe will probe functions in the program linkage table corresponding to the rest of the probe point
process(PID).plt("NAME").return
process(PID).statement("*@FILE.c:123")
process(PID).statement("*@FILE.c:123").nearest <-- Places a probe at the nearest available line number for each line number given in the statement.
process(PID).statement(ADDRESS).absolute
  - use raw (unverified) virtual addresses
process("PATH").mark("LABEL")
  - This is for instrumented code(code should have STAP_PROBE1). A .mark probe gets called via a static probe which is defined in the application by STAP_PROBE1(PROVIDER,LABEL,arg1), which are macros defined in sys/sdt.h.


process(PID).begin
process("FULLPATH").begin
process.begin
 - A process.begin probe gets called when new process described by PID or FULLPATH gets created. In addition, it is called once from the context of each preexisting process, at systemtap script startup. This is useful to track live processes

process(PID).thread.begin
process("FULLPATH").thread.begin
process.thread.begin
  -  A process.thread.begin probe gets called when a new thread described by PID or FULLPATH gets created.
process(PID).end
process("FULLPATH").end
process.end
process(PID).thread.end
process("FULLPATH").thread.end
process.thread.end

process(PID).syscall
process("FULLPATH").syscall
process.syscall
 - The system call number is available in the $syscall context variable, and the first 6 arguments of the system call are available in the $argN (ex. $arg1, $arg2, ...) context variable.
 
process(PID).syscall.return
process("FULLPATH").syscall.return
process.syscall.return
  - the return value of the system call is available in the $return context variabl
  
process(PID).insn
process("FULLPATH").insn
process(PID).insn.block
process("FULLPATH").insn.block
 - A process.insn probe gets called for every single-stepped instruction of the process described by PID or FULLPATH. A process.insn.block probe gets called for every block-stepped instruction of the process described by PID or FULLPATH


What to print:
-------------------
Ref: https://sourceware.org/systemtap/tutorial.pdf
tid() The id of the current thread.
pid() The process (task group) id of the current thread.
uid() The id of the current user.
execname() The name of the current process.
cpu() The current cpu number.
gettimeofday_s() Number of seconds since epoch.
get_cycles() Snapshot of hardware cycle counter.
pp() A string describing the probe point being currently handled.
ppfunc() If known, the the function name in which this probe was placed.
$$vars If available, a pretty-printed listing of all local variables in scope.
print_backtrace() If possible, print a kernel backtrace.
print_ubacktrace() If possible, print a user-space backtrace.


Multiple probes can be specified using a ","
---------------------------------------------------

sudo stap -e 'probe process("/tmp/foo.so").function("f1"),process("/tmp/foo.so").function("f2") { printf("hello");}'


==========================================================

